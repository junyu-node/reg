

//^      匹配字符串的开头 如果设置了RegExp对象的Multiline属性， 也匹配\n \r 后的位置
//$      匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。
var aa=/^\w+/gm;
var bb='sdasds1234523454\nsadhdasdj';

var arr=bb.match(aa);
console.log(arr)//[ 'sdasds1234523454', 'sadhdasdj' ]


// * 匹配前面的子表达式任意次。例如，zo*能匹配“z”，“zo”以及“zoo”，但是不匹配“bo”。*等价于{0,}
// + 匹配前面的子表达式至少一次 等价于 {1,}
// ? 可有可无 等价于{0,1}
// {n} n个
// ｛n,｝ 至少n个
// {n,m} n-m个



var cc=/\w*/g;
console.log(cc.test('swe5462121'))//true;
console.log(cc.test('212sdsa'))//false;


// x|y 或的关系 等价于 [xy]
//[^xy] 非xy
//[a-z] a到 z
// [^a-z] 非 a-z

// \b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。
// \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。


// \d 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持
// \D 匹配一个非数字字符。等价于[^0-9]。grep要加上-Pperl正则支持
// \n 匹配一个换行符。等价于\x0a和\cJ。
// \r 匹配一个回车符。等价于\x0d和\cM。
// \s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。
// \S 匹配任何可见字符。等价于[^ \f\n\r\t\v]。
// \w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的"单词"字符使用Unicode字符集。
// \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。


